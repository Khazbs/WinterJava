# Задача 7\*
[Repl.It](https://repl.it/@ArthurKhazbs/WinterJavaTask-7X)

```text
Мы не можем не следить за развитием событий в компании с колл-центром. Компания решила каждую неделю выплачивать премию самому активному оператору: оператору, обслужившему наибольшее количество звонков.

За неделю в колл-центре собирается 7 файлов логов (по одному за день) и все они довольно большие. Поэтому разработчики решили вычислять счастливчика в параллельном режиме.

Для заданного списка путей файлов логов требуется реализовать функцию:

public String getBestWorker(List<String> logs) {
  // TODO
}

которая возвращает логин оператора, принявшего наибольшее количество звонков по данным всех логов за неделю. При этом функция должна работать в многопоточном режиме: каждый лог обрабатывается отдельным потоком.

Как и прежде, лог содержит записи за один день, каждая из которых имеет вид: "call_start_ms,call_end_ms,operator_login".

P.S.:

Для ожидания завершения потока в Java используется метод join() класса Thread, который останавливает текущий поток до завершения потока, на котором он вызван.

Пример:

// создание двух потоков 
// с переопределенным методом run()
Thread t1 = new MyThread();
Thread t2 = new MyThread();
// запуск потоков
t1.start();
t2.start();
// ожидание завершения работы t1 и t2
t1.join();
t2.join();
// в этом месте t1 и t2 закончили работу  

```
